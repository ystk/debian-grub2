Description: Handle Xen split-partition disk image devices
 If opening the disk device returns GRUB_ERR_UNKNOWN_DEVICE, treat the
 partition device as a disk in its own right.  This can happen with Xen disk
 images.
Author: Colin Watson <cjwatson@ubuntu.com>
Bug-Debian: http://bugs.debian.org/601974
Forwarded: yes
Applied-Upstream: http://bazaar.launchpad.net/~vcs-imports/grub/grub2-bzr/revision/2832
Last-Update: 2011-06-11

Index: b/kern/emu/hostdisk.c
===================================================================
--- a/kern/emu/hostdisk.c
+++ b/kern/emu/hostdisk.c
@@ -1353,12 +1353,15 @@
 #endif /* defined(__NetBSD__) */
 
 static int
-find_system_device (const char *os_dev, struct stat *st)
+find_system_device (const char *os_dev, struct stat *st, int convert)
 {
   unsigned int i;
   char *os_disk;
 
-  os_disk = convert_system_partition_to_system_disk (os_dev, st);
+  if (convert)
+    os_disk = convert_system_partition_to_system_disk (os_dev, st);
+  else
+    os_disk = xstrdup (os_dev);
   if (! os_disk)
     return -1;
 
@@ -1392,7 +1395,7 @@
       return 0;
     }
 
-  drive = find_system_device (os_dev, &st);
+  drive = find_system_device (os_dev, &st, 1);
   if (drive < 0)
     {
       grub_error (GRUB_ERR_UNKNOWN_DEVICE,
@@ -1498,7 +1501,32 @@
     free (name);
 
     if (! disk)
-      return 0;
+      {
+	/* We already know that the partition exists.  Given that we already
+	   checked the device map above, we can only get
+	   GRUB_ERR_UNKNOWN_DEVICE at this point if the disk does not exist.
+	   This can happen on Xen, where disk images in the host can be
+	   assigned to devices that have partition-like names in the guest
+	   but are really more like disks.  */
+	if (grub_errno == GRUB_ERR_UNKNOWN_DEVICE)
+	  {
+	    grub_util_warn
+	      ("disk does not exist, so falling back to partition device %s",
+	       os_dev);
+
+	    drive = find_system_device (os_dev, &st, 0);
+	    if (drive < 0)
+	      {
+		grub_error (GRUB_ERR_UNKNOWN_DEVICE,
+			    "no mapping exists for `%s'", os_dev);
+		return 0;
+	      }
+
+	    return make_device_name (drive, -1, -1);
+	  }
+	else
+	  return 0;
+      }
 
     partname = NULL;
     grub_partition_iterate (disk, find_partition);
