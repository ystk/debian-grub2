Description: Fix efiemu
 Without this, lzo.patch causes efiemu not to be built.
Author: Vladimir Serbinenko <phcoder@gmail.com>
Origin: upstream, http://bazaar.launchpad.net/~vcs-imports/grub/grub2-bzr/revision/3740
Origin: upstream, http://bazaar.launchpad.net/~vcs-imports/grub/grub2-bzr/revision/4066
Forwarded: not-needed
Applied-Upstream: http://bazaar.launchpad.net/~vcs-imports/grub/grub2-bzr/revision/3740
Last-Update: 2012-03-19

Index: b/configure.ac
===================================================================
--- a/configure.ac
+++ b/configure.ac
@@ -479,6 +479,42 @@
 esac
 AC_MSG_RESULT([$TARGET_OBJ2ELF])
 
+
+AC_ARG_ENABLE([efiemu],
+	      [AS_HELP_STRING([--enable-efiemu],
+                             [build and install the efiemu runtimes (default=guessed)])])
+if test x"$enable_efiemu" = xno ; then
+  efiemu_excuse="explicitly disabled"
+fi
+if test x"$target_cpu" != xi386 ; then
+  efiemu_excuse="only available on i386"
+fi
+if test x"$platform" = xefi ; then
+  efiemu_excuse="not available on efi"
+fi
+if test x"$efiemu_excuse" = x ; then
+  AC_CACHE_CHECK([whether options required for efiemu work], grub_cv_cc_efiemu, [
+    SAVED_CFLAGS="$CFLAGS"
+    CFLAGS="$CFLAGS -m64 -mcmodel=large -mno-red-zone -nostdlib"
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[]])],
+		      [grub_cv_cc_efiemu=yes],
+		      [grub_cv_cc_efiemu=no])
+    CFLAGS="$SAVED_CFLAGS"
+  ])
+  if test x$grub_cv_cc_efiemu = xno; then
+     efiemu_excuse="cannot compile with -m64 -mcmodel=large -mno-red-zone -nostdlib"
+  fi
+fi
+if test x"$enable_efiemu" = xyes && test x"$efiemu_excuse" != x ; then
+  AC_MSG_ERROR([efiemu runtime was explicitly requested but can't be compiled])
+fi
+if test x"$efiemu_excuse" = x ; then
+enable_efiemu=yes
+else
+enable_efiemu=no
+fi
+AC_SUBST([enable_efiemu])
+
 if test "x$target_m32" = x1; then
   # Force 32-bit mode.
   TARGET_CFLAGS="$TARGET_CFLAGS -m32"
@@ -638,39 +674,6 @@
   grub_I386_ASM_ADDR32
 fi
 
-AC_ARG_ENABLE([efiemu],
-	      [AS_HELP_STRING([--enable-efiemu],
-                             [build and install the efiemu runtimes (default=guessed)])])
-if test x"$enable_efiemu" = xno ; then
-  efiemu_excuse="explicitly disabled"
-fi
-if test x"$target_cpu" != xi386 ; then
-  efiemu_excuse="only available on i386"
-fi
-if test x"$platform" = xefi ; then
-  efiemu_excuse="not available on efi"
-fi
-if test x"$efiemu_excuse" = x ; then
-  AC_CACHE_CHECK([whether options required for efiemu work], grub_cv_cc_efiemu, [
-    CFLAGS="$CFLAGS -m64 -mcmodel=large -mno-red-zone -nostdlib"
-    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[]])],
-		      [grub_cv_cc_efiemu=yes],
-		      [grub_cv_cc_efiemu=no])
-  ])
-  if test x$grub_cv_cc_efiemu = xno; then
-     efiemu_excuse="cannot compile with -m64 -mcmodel=large -mno-red-zone -nostdlib"
-  fi
-fi
-if test x"$enable_efiemu" = xyes && test x"$efiemu_excuse" != x ; then
-  AC_MSG_ERROR([efiemu runtime was explicitly requested but can't be compiled])
-fi
-if test x"$efiemu_excuse" = x ; then
-enable_efiemu=yes
-else
-enable_efiemu=no
-fi
-AC_SUBST([enable_efiemu])
-
 if test "$platform" != emu; then
 AC_CACHE_CHECK([whether -nostdinc -isystem works], [grub_cv_cc_isystem], [
   SAVED_CPPFLAGS="$CPPFLAGS"
Index: b/grub-core/efiemu/runtime/efiemu.c
===================================================================
--- a/grub-core/efiemu/runtime/efiemu.c
+++ b/grub-core/efiemu/runtime/efiemu.c
@@ -21,6 +21,12 @@
    As it emulates only runtime serviceit isn't able
    to chainload EFI bootloader on non-EFI system (TODO) */
 
+#ifdef __i386__
+#include <grub/i386/types.h>
+#else
+#include <grub/x86_64/types.h>
+#endif
+
 #include <grub/symbol.h>
 #include <grub/types.h>
 #include <grub/efi/api.h>
@@ -369,16 +375,16 @@
       switch (cur_relloc->size)
 	{
 	case 8:
-	  *((grub_uint64_t *) UINT_TO_PTR (cur_relloc->addr)) += corr;
+	  *((grub_uint64_t *) (grub_addr_t) cur_relloc->addr) += corr;
 	  break;
 	case 4:
-	  *((grub_uint32_t *) UINT_TO_PTR (cur_relloc->addr)) += corr;
+	  *((grub_uint32_t *) (grub_addr_t) cur_relloc->addr) += corr;
 	  break;
 	case 2:
-	  *((grub_uint16_t *) UINT_TO_PTR (cur_relloc->addr)) += corr;
+	  *((grub_uint16_t *) (grub_addr_t) cur_relloc->addr) += corr;
 	  break;
 	case 1:
-	  *((grub_uint8_t *) UINT_TO_PTR (cur_relloc->addr)) += corr;
+	  *((grub_uint8_t *) (grub_addr_t) cur_relloc->addr) += corr;
 	  break;
 	}
     }
